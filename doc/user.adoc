// Copyright 2012 Aaron Ecay

// This work is licensed under a Creative Commons
// Attribution-NonCommercial-NoDerivs 3.0 Unported License
// http://creativecommons.org/licenses/by-nc-nd/3.0/deed.en_US

// License to be changed to something less restrictive once this is
// release-ready (either CC-BY-SA or CC-BY-SA-NC)

// Include the file with author info, and use our custom configuration:
//   a2x: --asciidoc-opts="-f user.conf -a docinfo"
// Include the default stylesheet and our customizations:
//   a2x: --stylesheet="docbook-xsl.css annotald-manual.css"
// Highlight source in output (TODO not working)
//   a2x: --xsltproc-opts "--stringparam highlight.source 1"


// Notes to contributors:
// Please add yourself to the user-docinfo.xml file and the copyright
// line (unless you wish to assign copyright to your contributions to
// the other authors)
// In addition to standard Asciidoc formatting, the following
// conventions are used in this file:
// - text which corresponds to the contents of a parse (.psd file)
//   should be surrounded with =equals signs=


= Annotald User’s Guide

// TODO: once this is reasonably complete, add internal links to and
// from various parts of the documentation

// TODO: centering pictures doesn’t work

== Introduction

This manual is designed to teach users how to use the Annotald program
for annotating parsed corpora according to (a version of) the Penn
treebank standards.
// TODO: link, also our labgroup updates (incorp. latter into this doc?)
In that vein, it consists of both documentation relating to the
configuration and use of Annotald, as well as instruction on the
application of the Penn treebank standards to corpus data.  For
simplicity, the annotation examples in this guide will be based on
modern English.  The principles illustrated should be applicable to
annotation in all languages, however.

Annotald was originally written as part of the
http://www.linguist.is/icelandic_treebank/Icelandic_Parsed_Historical_Corpus_%28IcePaHC%29[Icelandic
Parsed Historical Corpus] (IcePaHC) project.  Development of the program
has been funded by:

- The Icelandic Research Fund (RANNÍS)
- The US’s National Science Foundation
- The University of Iceland Research Fund
- Research funds at the University of Pennsylvania

// eventually: availability of annotation seminars etc.

== Installation

In order to use Annotald, it is necessary to install several programs
that Annotald depends on in order to function.  Like Annotald itself,
all of these programs are Free Software.footnote:[There are two meanings
of the term “Free Software.”  The first refers to the software being
provided free of charge.  The second means that the software’s source
code is freely available to its users for them to inspect, modify, and
reuse.  The second of these definitions is the most important to
ensuring scientific openness; as it happens Annotald and its
dependencies fulfill both definitions.]

Some of Annotald’s dependencies may require a C compiler; for Macs this is
available by installing Apple’s no-cost XCode toolkit, and then choosing
to download the “Command Line Tools” from the “Downloads” preference pane
within the XCode application.  These are the instructions to install
Annotald on Mac and Linux:

1. Download and install the latest stable version of
   https://www.google.com/intl/en/chrome/browser/?hl=en&lr=all[Google’s
   Chrome web browser]
2. Install the latest stable version of Python 2, if necessary.
   Macintosh computers have a sufficient version of Python
   pre-installed.  (If you use Linux, it is also very likely that Python
   2 is already installed on your computer.)
3. Follow the http://nltk.org/install.html[instructions] given by the
   Natural Language Toolkit project to install the `pip` command on your
   computer.
4. Download the latest release of Annotald from TODO: link.  Open a
   terminal on your computer, and type `pip install
   path/to/Annotald-x.y.z.tar.gz` (replacing `path/to/` with an
   appropriate path you your computer’s download folder and `x.y.z` with
   the version of the most recent Annotald release).
5. Annotald and its dependencies will now be automatically installed.

Once this is done, Annotald is ready to use.  At a terminal command
prompt, type `annotald path/to/file.psd` (supplying the path to a file
in the Penn treebank format; if a sample file is needed you can use
https://raw.github.com/antonkarl/icecorpus/6ad3006cc004aefdcbdda99c188d02afa9cbe7d0/finished/1150.firstgrammar.sci-lin.psd[this
file from the IcePaHC project]).  Then, open the Chrome browser, and
navigate to `http://localhost:8080`.  You should see the Annotald
interface appear.  The rest of this manual is concerned with using and
customizing the program.

NOTE: If you are not able to install Annotald successfully, you can open
an issue report at Annotald’s website on GitHub.
// TODO: link
This will put you in touch with Annotald’s developers, who will help you
solve the problem.  When creating issue reports, please try to describe
your computer’s configuration and the error message you received in
terms that are as accurate and concise as possible.

Installation instructions for windows remain to be written.
// TODO: Windows install

== Annotald UI and Philosophy

The Annotald user interface (UI) is shown in the following screenshot:

// TODO: is it necessary to redo this since search has been added? ugh.

image::images/annotald-hello.png[The Annotald UI at startup,align="center"]

On the left-hand side of the screen, the following are present, from top
to bottom:
- The control panel.  This contains buttons for functions such as
  saving, undo/redo, and clocking in/out from a timelog file.
- The tools panel.  Empty in this screenshot, this contains advanced
  functionality when enabled, such as external validation.
- The messages pane.  This area displays messages from the
  program to the user.

Various Annotald functions involve showing a dialog box to the user.
For example, the following image demonstrates the message history dialog
(accessed by clicking “Messages” above the message area).  To dismiss a
dialog, press the escape key.  (Different dialogs may also display
buttons allowing you to close them).

image::images/annotald-dialog.png[An example of a dialog box in Annotald,align="center"]

The right-hand portion of the screen is devoted to showing the contents
of the file being edited.  The tree structure of the annotation is
represented as a series of concentric boxes.  Clauses are highlighted in
dark pink, in order to make them more salient, and provide an additional visual
reference to the structure of the sentences being edited.  The box which
represents the file itself is dark brown.

// editing operations cannot change the text

There are three ways of interacting with Annotald’s user interface.  

=== Mouse

It is recommended that Annotald users have a full-sized mouse with at least
two buttons.  Because of Annotald’s heavy reliance on mousing, neither a
laptop trackpad nor a single-button mouse will prove satisfactory from an
ergonomic point of view.

The mouse serves to select nodes in the UI.  Click anywhere in the box
corresponding to a node in order to select it.  The horizontal mouse
motion necessary can be reduced by clicking on the left edge of the
node; the left side of each node’s box is padded in order ot facilitate
this.  An example of a selected node is shown here, notice that the
selected node has been highlighted in blue:

image::images/annotald-select.png[Selection in the Annotald UI,align="center"]

Up to two nodes may be selected at a time.  If a node is selected,
clicking another node will also highlight that node:

image::images/annotald-select2.png[Dual selection in the Annotald UI,align="center"]

Further clicks after two nodes are selected will de-highlight the
previous second selection, and highlight the clicked node.  To clear any
selection in effect, use the space bar.

Selected nodes form the basis for many <<keycmds,keyboard commands>>.
Node selection is also the basis of movement commands, of a certain
type.  The mouse is used for movement commands that edit the structure
of the tree.  In order to annotate movement in the sense of linguistic
movement (wh-movement, etc.), see the <<leafAfter,`leafAfter`>> and
<<leafBefore,`leafBefore`>> functions.

In order to move a selected node, right click on the desired
destination.  Movements must satisfy certain structural (e.g. a node
cannot be moved into its own daughter) as well as extrinsic conditions
(no movement operation may change the text of the sentence, e.g. by
reordering two words).  Assuming these conditions are met, the movement
operation will take place.  Right clicking with two selected nodes will
move those nodes, as well as any intervening material, to the desired
destination.  The two selected nodes must be sisters of each other.

// TODO: ctrl click -> new xp

// TODO: mouse wheel...document, or remove the code

=== Context menu

Right-clicking a node when no selection is present will summon the
context menu, which is illustrated here:

image::images/annotald-context.png[The Annotald context menu,align="center"]

The context menu has three columns.  The first has suggested label
changes for the node; clicking any of these will change the node’s label
to the chosen option.  The second contains options for adding a sister
before the node; clicking any of these will insert a node with the given
label and text.  The third column contains options for toggling certain
dash tags.

// TODO: split context menu dash tags from all dash tags in config file

The context menu can be dismissed by left-clicking outside of it.

=== Keyboard

Annotald operations other than movement are controlled by the keyboard.
Annotald users should keep their right hand on the mouse at all times;
thus, only keys on the left hand side of the keyboard are used as key
shortcuts (with a small number of exceptions for commands which require
full keyborad use).footnote:[Left handed users may wish to use the left
hand for mousing and the right hand for the keyboard, but the principle
of using one hand exclusively for each operation remains the same.
Additionally, the default configuration will have to be adjusted for
users of non-English keyboard layouts.]

// TODO: link to section about customizing keybindings


== Customization

// TODO: section about writing custom functions in javascript

=== Command line options

When invoked via the command line, there are several options which can
be passed to Annotald to affect its behavior.  These are:

`-s PATH`:: Specify the path to the javascript settings file.  If this
is not specified, the default settings file distributed with Annotald is
used.
// TODO: link

`-S PATH`:: Specify the path to the python settings file.  If this is
not specified, the default settings file distributed with Annotald is
used.
// TODO: link

`-p NUMBER`:: Specify the port which Annotald will run its server.  The
default is 8080 (possible values range between 1025 and 65535).  Only
one program may listen to a given port, so if you would like to run more
than one instance of Annotald concurrently, you must specify a different
port for each of them.
// TODO: how to specify port in the browser

`-o`:: Specify that the file to be read from is a CorpusSearch output
file.  CorpusSearch comments will be stripped from the file on reading.

`-q`:: Deactivate the time-logging function.
// TODO: link to doc

`-n NUMBER`:: Show only NUMBER trees fo the file at a time.
// TODO: link to doc

`-1`:: A shortcut which is equivalent to `-n 1`

=== Javascript customization options

// TODO: revise/remove this paragraph
There are two files which are relavant to the customization of Annotald:
`settings.js` and `settings.py`.  The former is written in Javascript,
and contains the bulk of Annotald’s user interface settings.  The latter
is written in Python, and (generally speaking) contains customizations
that are very pervasive or advanced.  A commented sample version of both
files is included in the Annotald download, which it is recommended for
users to base their customizations on.

In this section, the options in `settings.js` will be discussed.  Options
specifiable in `settings.py` on the other hand will be discussed in
other sections where they are implicated.

// TODO: discussion assumes familiarity with penn treebank conventions,
// include note to read intro to annotation section first if reader is
// not familiar

[[casevars]]`displayCaseMenu`:: Whether or not to display options for changing the
case of items in the context menu.  See the discussion of this feature
<<casemenu,below>>

`caseTags`:: A list of the labels which can receive a tag indicating
their case.  Generally speaking, these will be leaf nodes.  Although an
entire NP (for example) might be said to have case, the only surface
reflexes of case are the marking of individual words.  Furthermore, as
is evident from number marking in some dialects of Spanish (TODO: cite
literature), within a single NP it is possible for some constituents to
not express the phrase’s features.
+
Therefore, the minimal annotation that captures the linguistic facts
places case on the leaf nodes; phrasal case can be calculated based on
that information.
// TODO: this broader philosophical point needs to be explicated
// elsewhere, like in an annotation philosophy section.
However, Annotald provides functions to make this less tedious – to
allow the annotator to mark a whole NP for case, and have that
information updated on all the relevant subconstituents of that NP.

`casePhrases`:: A list of phrasal categories that bear case.  These will
provide an option in the context menu to set their case (which actually
sets the case of their subconstituents).

`caseMarkers`:: A list of case markers.  Each of these is a dash tag
(given in the Javascript file without surrounding dashes) that may be
attachedto a member of `caseTags` to indicate its case.

`caseBarriers`:: A list of phrases which should form barriers to
recursive case assignment.  When case is assigned to an NP, Annotald
looks (recursively) for all its daughters which are case-marker-bearing,
and changes their case.  But, this process should not recurse into
e.g. a relative clause, or a genitive possessor.  Thus, any node in this
list will block further case-setting traversal.

NOTE: The variables `caseTags`, `casePhrases`, and `caseBarriers` cannot
contain dashes; they must be genuine top-level category labels.

`testValidPhraseLabel`/`testValidLeafLabel`:: See the discussion of
these options <<tagset-validate,below>>

[[extensions-vars]]
`extensions`:: Specify the list and order of dash tags available in the
corpus.  There are three variants of this variable:
- `leaf_extensions`: Dash tags applicable to leaf (terminal) nodes
- `clause_extensions`: Dash tags applicable to clausal nodes (of
  category CP or IP)
- `extensions`: Dash tags applicable to non-clausal non-leaf nodes

+
Not every dash tag needs to appear in this list, only those which need to
be toggled on and off in a binary fashion.  Thus, for example, the dash
tag =OB1= (for direct objects) is never toggled in a binary fashion, but
rather as part of a cycle that includes setting the category to =NP= and
moving through =NP-SBJ=, =NP-OB2=, etc.  Thus, it need not appear in this
list.  However, the =SPE= dash tag (for reported speech) is toggled on
and off – changing an =IP-XXX= to =IP-XXX-SPE=, and potentially back to
IP-XXX.
// TODO: this is a bad explanation.  Maybe require to list all dash
// tags?  but that gets tedious.

`ipnodes`:: A list of categories which are clauses.  These are
highlighted (with a tan shade) to make it clear where the “floor” of a
clause is, for the purpose of rearranging nodes in the user interface.

`invisibleCategories`:: TODO: what to do about these?

`commentTypes`:: [[commenttypes-vars]] Types of comments.  Comments
are nodes of the form =(CODE \{XXX:words_words_words})= For every
value of “XXX” is in this list, when editing the contents of the
comment with one of the editing functions (TODO: link), a dialog box
will appear allowing the comment to be edited as text, instead of the
default editing interface.

`customCommands`:: A Javascript function containing code to configure
the keybindings.  This should be a series of calls to the
link:../api-doc/symbols/global.html#addCommand[`addCommand` function].

`defaultConMenuGroup`:: The label suggestions to display in the
context (right-click) menu, when no suggestion can be deduced from
the already-present label.

`customConMenuGroups`:: a Javascript function to configure the context
menu suggestions.  This should be a series of calls to the
link:../api-doc/symbols/global.html#addConMenuGroup[`addConMenuGroup` function].

`customConLeafBefore`:: a Javascript function to configure the new node
options in the context menu.  This should be a series of calls to the
link:../api-doc/symbols/global.html#addConLeafBefore[`addConLeafBefore` function].

// TODO: styleTag

[[keycmds]]
=== Default keybindings

The Annotald keybindings provided by default are adapted from those used
by the IcePaHC project.  It is highly recommended that users make a copy
of this file in the working directory for their corpus, and customize it
to their needs.  The procedure to do so is described in the following
section.  The default keybindings are as follows (from left to
right and top to bottom of a US keyboard layout):footnote:[To see an
exact listing of the tags included in each category described below, you
should consult the configuration file itself.]

Backquote (`):: Toggle the display of lemmata on or off

1:: Unbound

2:: Cycle between tags for non-argument NPs

3:: Unbound

4:: Toggle the =-PRN= dash tag (parentheticals)

5:: Toggle the =-SPE= dash tag (direct speech)

Q:: Cycle between tags for miscellaneous phrase types

W:: Cycle between tags for argumental NPs

E:: Cycle between tags for miscellaneous CPs

R:: Cycle between tags for relative clauses

T:: Cycle between tags for that-clauses and other types of CP

A:: Add a leaf after the selected node

S:: Cycle between tags for different types of sentential IP

D:: Delete a node

F:: Cycle between tags for PPs and ADVPs

G:: Cycle between tags for ADJPs and QPs

Z:: Undo

X:: Create a new node (labeled XP)

C:: Coindex nodes

V:: Cycle between tags for non-sentential IPs

Spacebar:: Clear the selection

L:: Edit the Label and/or text of a node

Shift + L:: The same (included as an example of a keybinding with modifier)


=== Custom keybindings

It is virtually certain that users will want to adapt the default key
bindings, to adapt the tags used and the most common use patterns of the
annotators.  It is possible to merely change the specific tags used
while maintaining the default conceptual categories (argumental NP,
non-sentential IP, etc.); it is also possible to come up with an
entirely new scheme.  The default bindings do not use the shift or
control modifiers, which opens up a large space of additional keys for
user customization.

The keybindings of Annotald are customized by placing calls to the
`addCommand` function inside the `customCommands` block.  This function
has 2 required arguments; any further arguments are determined by the
command being bound.  The first argument to the function should be a
Javascript dictionary (also known as an object).  This has the format
`{key: value, key2: value2}`.  The following keys are recognized:

- `keycode` the numeric Javascript keycode of the key you wish to bind.
  You can navigate to
  http://www.asquare.net/javascript/tests/KeyCode.html[this website] to
  determine interactively the code for any key on your keyboard.
- `ctrl` the value `true` if this binding is for a shortcut with the
  control key pressed.  Ergonomically, it is much easier to actuate such
  shortcuts if you remap the “Caps Lock” key on your keyboard to
  control, so that it can be pressed with the pinky without needing to
  reach very far.  A panoply of methods to do so are presented at
  http://emacswiki.org/emacs/MovingTheCtrlKey[this website].
- `shift` the value true if this binding is for a shortcut with the
  shift key pressed.

The `ctrl` and `shift` options are mutually exclusive.

The second argument to the `addCommand` function is the name of the
function which the key will be bound to.  Any further arguments will be
passed to the function given.  A list of functions provided by Annotald
follows:

`clearSelection`:: Remove any selected node(s).  No arguments.

`coIndex`:: Various effects related to the numeric suffixes that
indicate movement/coreference/etc. chains:
- If called with only one node selected: remove this node’s numeric
  index.
- If called with two nodes selected, only one of which has an index:
  add an index matching the indexed node to the non-indexed node.
- If called with two nodes selected, neither of which has an index: add
  matching indices to both nodes.
- If called with two nodes selected whose indices match: cycle through
  different index types.  The cycle is: regular indices (both indices
  appended with `-`) -> gapping (first index appended with `=`) ->
  backwards gaping (second index appended with `=`) -> double gapping
  (both indices appended with `=`) -> remove indices.

+
No arguments.

// TODO: better name
`displayRename`:: Edit the text of the currently selected node.  If this
is a non-terminal, edit its label.  If this is a terminal, allow editing
its label, lemma (if present) and text (iff the text is an “empty element”
– trace, comment, etc.)  This function handles <<commenttypes-vars,comment
nodes>> specially.  No arguments.

// editLemmaOrLabel – do we want to document this fn?  remove from source?

`leafAfter`, `leafBefore`:: [[leafBefore]] [[leafAfter]] Create a leaf node
after or before the (first-)selected node.  A heuristic is used to
determine the type of node to create.  If only one node is selected, the
default is to create an empty conjoined subject (i.e. =(NP-SBJ \*con*)=)
If there are two nodes selected, the second-selected node determines the
type of leaf to make.  If this node is:
- a wh-phrase (label begins with =W=), a wh-trace (=\*T*=) is created
- a clitic (label contains the dash tag =CL=), a clitic trace (=\*CL*=)
  is created
- otherwise, an extraposition trace (=\*ICH*=) is created

+
The label of the created node in these cases is determined by the label
of the second-selected node.  Generally, the label of that node is
copied, except:
- in the case of a wh-trace, the leading =W= is stripped (so the trace
  of a =WNP= is an =NP=, etc.)
- in the case of a clitic trace, the =CL= dash tag is stripped and =PRO=
  is transformed to =NP= (so the trace of =PRO-CL= is an =NP=, and the trace
  of =ADVP-CL= is =ADVP=).
+
Additionally, the trace and its antecedent (the second-selected node)
are coindexed.  No arguments.

`makeNode`:: Create a new node dominating the selected node,
or the span between the two selected nodes (inclusive).  This function
takes an optional argument specifying the label of the node to create;
if not present, the label of the new node will be “XP”.  One optional argument.

`pruneNode`:: Delete the selected node.  If a non-terminal node is
selected, the operation always succeeds, and the daughters of the
deleted node become daughters of the deleted node’s parent.  If a
terminal node is selected, the operation can succeed only if the node is
empty of textual content.  No arguments.
// TODO: add definition of empty text (philosophy section?), link to it

`setLabel`:: Set the label of the selected node.  The argument must be a
list of labels.  If the node’s current label is not present in the list,
it is set to the first entry in the list.  Otherwise, it is set to the
node immediately following its current label in the list (wrapping
around at the end of the list).  To illustrate, if the “f” key is bound
to `setLabel` with an argument of `["FOO","BAR"]`, selecting a node with
label “QUUX” and pressing the “f” key sequentially will yield:
1. the label being set to =FOO= (since “QUUX” is not in the provided
   list)
2. the label being set to =BAR= (since “BAR” follows “FOO” in the list)
3. the label being set to =FOO= (since “BAR” is at the end of the list,
   wrap to the beginning)
4. etc.

+
One argument.

`toggleExtension`:: Toggle a dash tag on the selected node.  If the (first)
argument exists as a dash tag on the node, remove it.  Otherwise, add it.
The optional second argument gives a list of extensions in the order they
should appear from the base category out; if not given, it is filled from
one of <<extensions-vars,the `extensions`-family variables>> based on a
heuristic as to the type of node which is selected.  One mandatory and one
optional argument.

`toggleLemmata`:: Toggle whether lemmata are shown or hidden in the
UI.  No arguments.

`undo`/`redo`:: Undo the most recent editing operations, or redo after
undoing something.  No arguments.


== Advanced features

In this section, some advanced features of Annotald are described.
These are not required to use Annotald (and in fact are deactivated by
default).  However, for proficient users, their use may make possible
grater annotation efficiency and accuracy.

[[tagset-validate]]
=== Tagset validation

// TODO: make sure that annotald uses this info everywhere it can.

By default, Annotald does not contain a mechanism to ensure that tags
created through editing conform to any sort of schema.  At the same
time, there are various parts of Annotald’s code that would benefit from
knowing whether a node corresponds to a leaf or not, which is not always
a purely structural decision (for example, a node of the form =(NP-SBJ
\*pro*)= is structurally a leaf, but in fact corresponds to a phrasal
node, an NP).  Supplying this information to Annotald improves its
functioning, as well as preventing nonsense tags from being added to the
corpus during editing.

You can do this however you like – the only requirement that Annotald
imposes is that you assign to the configuration variables `testValidLeafLabel`
and `testValidPhraseLabel` Javascript functions that return true iff its
argument is a valid label for a leaf node or phrase node
(respectively).  One useful way of doing this is described below.

It is possible to write a grammar to validate tags.  Just as the grammar
of a natrual language accepts only those sentences which are well-formed
in that language, this grammar should accept only the tags which are
valid in a particular corpus.  In particular, this manual will describe
how to use the http://waxeye.org/[Waxeye Parser Generator] to do so.  In
addition to being Free Software, this program uses a relatively
intuitive notation for its grammars.  Additionally, it can generate
grammars not only in Javascript, but also in Python and several other
computer languages.  This allows the same grammar specification to be
used in Annotald as well as in a validation script for the corpus.

Grammars written in waxeys consist of a series of rules.  The first rule
in the file constitutes the grammar – it must match.  A rule has the
form `name <- content`.  The name of a rule can consist of letters,
numbers, and underscores.  The content of the rule can be as follows:

- `'string'` matches string in the input, literally
- the name of another rule forces that rule to match
- `(...)` is a grouping construct
- `A B` matches A followed by B
- `A | B` matches either A or B
- `?A` matches maybe A – that is, if A matches, the parser’s input
  advances over it, but if A does not match, the parser does not fail.
- `*A` matches 0 or more A
- `+A` matches 1 or more A

Using these rules, it is possible to build up a grammar.  As an
illustration, here is a grammar that matches
http://www.ling.upenn.edu/histcorpora/annotation/labels.htm#pos_tags[the
tagset from the PPCEME] (without, for simplicity, the numbered word splitting).

// TODO: test this

----------
/* Subdivide types of tag, for simplicity */
word_tag <-
 ( verbal | nominal | punct | other_word | fn_cat )

/* TODO: comments! */

nominal <-
 ('NUM' ?'$') | ('N' ?'PR' ?'S' ?'$') | ('ADJ' ?('R' | 'S')) | 'D' |
 ('PRO' ?'$') | ('Q' ?('R' | 'S' | '$'))

verbal <-
 verb | verb_modifier

verb <-
 (('DO' | 'BE' | 'HV' | 'VB') ?('D' | 'P' | 'N' | 'I')) |
 (('D' | 'B' | 'H' | 'V') 'A' ('G' | 'N')) |
 ('MD' ?'0')

verb_modifier <-
 ('ADV' ?('R' | 'S')) | 'NEG'

punct <-
 '\'' | '"' |',' | '.' | '`'

fn_cat <-
 'C' | 'CONJ' | 'P' | ('W' ('ADV' | 'D' | ('PRO' ?'$'))) |
 'INTJ' | 'ALSO' | 'ELSE' | 'EX' | 'FP' | 'RP' | 'LB' | 'LS' |
 'MAN' | 'ONE' | ('OTHER' ?'S' ?'$') | 'SUCH' | 'TO' | 'WARD'

other_word <-
 'CODE' | 'FW' | 'X' | 'FP' | 'META'
----------

// TODO: num before n
// TODO: matching dashes in phrasal rules

// TODO: custom CSS

// TODO: n-trees mode

// TODO: settings.py options

=== External validation

Annotald includes a feature that allows the user to interactively submit
the contents of a file to a separate program, and receive feedback from
that program.  This system is (intentionally) very powerful – the
external program can be any Python function,footnote:[Which in turn may
invoke any program on the user’s computer] and the feedback comes in the
form of that function modifying the file contents; these modified file
contents replace the original file in the Annotald interface.  It is
hoped that this flexibility will facilitate a wide variety of automated
workflows.

One conventionalized way of using this facility is to perform
_validation queries_ on the file – queries that will find anomalous
structures, and flag them for annotator attnetion.footnote:[This idea
stems from discussions with Beatrice Santorini about how her parsing
methodology.]  In this section, we will discuss setting up such a
system, using CorpusSearch queries.

The specification of validation queries involves customizing the Python
settings file.  An annotated example of such a file is given immediately
below.

[source,python]
----------
import os.path
current_dir = os.path.dirname(os.path.abspath(__file__)) # <1>

from collections import OrderedDict # <2>

validators = OrderedDict([
    ("Example 1", corpusSearchValidate(current_dir + "/example1.q")), # <3>
    ("Example 2", corpusSearchValidate(current_dir + "/example2.q"))
])
----------

<1> An easy way to find in Python other necessary files (in this case,
CorpusSearch queries) is by locating them with relation to the Python
file itself.  This line assigns the directory where the script is
located (as a string) to the variable `current_dir`.
// TODO: could we simplify things, by using a decorator to add a name to
// fns, and then just using a list of fns?
<2> The format of the `validators` variable is a dictionary – a data
structure that associates keys (in this case, human-readable names of
validators) with values (validation functions).  The default dictionary
implementation in Python does not preserve the order of the key-value
pairs it stores.  This line allows us to use an alternative
implementation that does preserve this order.  This means that the order
which we specify validators in this file will be the order that they
appear in Annotald’s dropdown menu.
<3> We create an `OrderedDict` object, and assign it to the `validators`
variable.  Each entry in the dictionary is given as a pair of `(key,
value)`.

The `corpusSearchValidate` function takes one argument, giving the
path to a CorpusSearch query file.  It then arranges to run this query
on the file, and return the modified output.  The CorpusSearch program
is distributed with Annotald; however, this facility relies on a Java
executable being installed on your machine.  You can test this by
opening a command prompt and typing `java` followed by a carriage
return.  You should see a usage message from the java program; if you
instead receive an error message the program is not installed and/or
accessible.

By convention, the validator should add the =-FLAG= dash tag to
trees which are anomalous.  The “Next Error” button in the Annotald
interface will allow you to jump to the next flagged tree in the
file.  You can also attach a keybinding to the `nextValidationError`
function, if you would like to use the keyboard for this purpose.
The program removes any =-FLAG=s when the file is saved and when
submitting it to the validator.

When validators are specified, the Annotald interface shows the
“Validate” and “Next Error” buttons as well as the validator selection
menu in the “Tools” section of the left-hand column, as shown in the
below image:

image::images/annotald-validate.png[Validation interface in Annotald,align="center"]

The example given above assumes that two CorpusSearch query functions
are present in the same directory as the Python file.  For more
information about writing CorpusSearch queries, consult the
http://corpussearch.sourceforge.net/CS-manual/Contents.html[user’s
guide], esepcially (for present purposes) the
http://corpussearch.sourceforge.net/CS-manual/Revise.html[section on
uatomated corpus revision] which tells how to make changes to the
input.  As an example, the following CorpusSearch revision query adds a
=-FLAG= to all NPs:

----------
node: $ROOT

query: {1}NP* exists

append_label{1}: -FLAG
----------

If run in the Annotald interface, it produces this result:

image::images/annotald-validate-results.png[Validation results in the Annotald interface,align="center"]

=== Searching

Annotald has a structural search engine built in.  While it cannot
replicate the flexibility or (perhaps especially) speed of a dedicated
search program such as
http://corpussearch.sourceforge.net/[CorpusSearch], it is useful to be
able to search within the Annotald interface itself.  The search dialog
is accessed by clicking the “Search” button in the Tools menu.
// TODO: or via slash key
Within the dialog box, you will construct a visual representation of
your query, similar to the representation of trees in the Annotald
interface.

The simplest query tree contains only one leaf node.  The leaf has a
text box, into which the search string can be entered.  The string is
interpreted as a case-insensitive Javascript regular expression.  The
Javascript regular expression format is very similar to that used by
many programming languages.  A full description fo the format is outside
the scope of this document, but is available via
https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp[this
reference manual].  The leaf also has a drop-down box, which indicates
whether the search string is to match against the node labels, the text
of the corpus, or the lemmata.  The search string is additionally
left-anchored – that is, the beginning of the regular expression is
constrained to match the beginning of a node label or word.  Pressing
the “Search” button will execute the search.  Matches will be
highlighted with a yellow box, and the document will be scrolled to
display the next match.  A very simple query and its result is
illustrated in the following screenshots:

image::images/annotald-search-simple.png[A simple Annotald search,align="center"]

image::images/annotald-search-simple-result.png[Results of a simple Annotald search,align="center"]

Once the search has completed, two buttons will appear below the
“Search” button.  The first of these scrolls the document down to
display the next match.  The second removes teh hithlighting from serach
matches.

In addition to the search node where text can be entered, there is a
node consisting only of a plus sign (“+”).  Clicking this node adds a
sister to the search node.  Search nodes which are sisters are
interpreted as the (unordered) sisterhood relation.  An exampl of such a
search is given in the following two screenshots:

image::images/annotald-search-sister.png[A sisterhood Annotald search,align="center"]

image::images/annotald-search-sister-result.png[Results of a sisterhood Annotald search,align="center"]

Each search node has some buttons in the upper-right hand corner.  From
left to right, these are:

// TODO: add screen shot examples to all of these

Or (vertical bar):: This creates an “OR” node as the parent of the node
from which it is clicked.  The daughters of an “OR” node are interpreted
disjunctively, instead of conjunctively (the default).  An example of
such a search is shown in the follwoing screenshots:footnote:[Note that
the results are the same as the previously illustrated sisterhood
search, though the queries are distinct.]

image::images/annotald-search-or.png[A disjunctive Annotald search,align="center"]

image::images/annotald-search-or-result.png[Results of a disjunctive Annotald search,align="center"]

Deep (“D”):: This creates a deep search node as a daughter of the node
from which it is clicked.  By default, child search nodes require direct
daughterhood.  The children of deep nodes, in contrast, can match at any
depth.

Precedes (“>”):: This creates a precedes node as a sister of the node from
which it ic clicked.  By default, as mentioned above (and illustrated in
the screenshots), the sisterhood relation among search nodes in
interpreted without regard to directionality.  Precedes nodes, on the
other hand, impose a precedence relation on their daughter (whih is not
in fact interpreted as a daughter, but rather as a sister, of the
original node.)

Remove (“-”):: This removes the node from which it is clicked.  Any
daughters of this node are promoted to the node’s parent; if the node
has no daughters it simply disappears.

Add daughter (“+”):: This adds a daughter search node to the node from
which it is clicked.  The defaultinterpretation is direct daughterhood,
which can be changed by using a deep node, as already mentioned.

// TODO: allow drag and drop of nodes?  or buttons to move them?


[[casemenu]]
=== Case menu

// TODO: this isn’t really an “advanced feature;” consider reorganizing
// to soemwhere else

Annotald includes support for manipulating case marking information in
corpora which store that information in a supported format.  In order to
be supported, the case must:footnote:[The YCOE does not follow these
guidelines.  Case is marked on phrasal nodes with dash tags (as a
substitute for grammatical role marking: =SBJ= etc.), and on words with
a caret: =^N= for nominative etc.  The Penn parsed corpora of Middle
English and later time periods indicate genitive with a =$= which is
directly concatenated with a leaf’s label, but this is not the kind of
case-marking that this Annotald feature addresses.  The IcePaHC corpus
does obey these conditions (unsurprisingly, since Annotald comes from
that project), as does the Penn Parsed Corpus of Historical Greek.]

- be stored as dash tags,
- at the word level,
- without any unmarked default categories.

Then, <<casevars,some options>> need to be set in the configuration
file.  Once this is done, the context menu will contain options for
setting case:

image::images/case-menu.png[Annotald context menu with case-setting options,align="center"]

Invoking the context menu on an individual case-bearing node (one of
<<casevars,`caseTags`>>) will allow that node’s case to be changed
individually.  Invoking it on a case-bearing phrase (one of
<<casevars,`casePhrases`>>) will change the case of all that node’s
case-bearing daughters, without recursing too deeply.

// Things to talk about:
// - annotation philosophy (useful annotation vs. correct annotation, some
//   of beatrices ideas, etc)
// - the annotation itself (building up from nps to pps to verbs to
//   sentences/clauses)
// - extensions (morpho/semantic information, lemmatization, ...)

// corpus formats – old, dash, and deep

// what else???


// TODO: custom CSS – file, with functions in settings.js
